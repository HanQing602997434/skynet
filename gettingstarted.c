
//Getting Started
/*
    skynet入门Quickstart：

        skynet是为网络游戏服务器设计的轻量级框架，但它本身并没有为网络游戏特别设计的部分，尽可以用在其它领域。

        skynet并非开箱即用，不会引导你把服务器搭建起来，而是一套工具，只有知道你想做什么，它才会更有效率的帮助你。

    框架Framework：

        作为服务器，通常需要同时处理多分类似的业务。例如在网络游戏中，你需要同时想数千个用户提供服务；同时运作上百
        个副本，计算副本中的战斗、让NPC通过AI工作起来，等等。在单核年代，我们通常在CPU上轮流处理这些业务，给用户造
        成并行的假象。而现代计算机，则可以配置多达数十个核心，如何充分利用它们并行运作数千个相互独立的业务，是设计
        skynet的初衷。

        简单的web服务倾向于把和用户相关的状态信息存储在数据库，通过用户进行对数据库进行操作和更新。而网络游戏通常有
        更强的上下文，以及多个用户间更复杂的交互。如果采用相同的模块，数据库和业务处理间很容易出现瓶颈，这个瓶颈甚至
        不能通常增加一个cache层来完全解决。

        在skynet中，用服务（service）概念来表达某项具体业务，它包括了处理业务的逻辑以及关联的数据状态。使用skynet
        实现游戏服务器时，不建议把业务状态挂到数据库中，而是存放在服务的内存数据结构里。服务、连同服务处理业务的逻辑
        代码和业务关联的状态数据，都是常驻内存的。如果数据库时你架构的一部分，那么大多数情况下，它扮演的是一个数据
        备份的角色。你可以在状态改变时，把数据推到数据库保存，也可以定期写到数据库备份。业务处理时直接使用内存的数据
        结构。

        由于skynet服务并非独立进程，所以服务间的通讯也可以被实现的高效得多。另一方面，由于这些服务同时存在于同一个
        skynet进程下，我们认为它们同生共死。在编写服务间协作的代码时，不用刻意考虑对方是否还活着、通讯是否可靠的问题。
        大多数skynet服务使用lua编写，lua的虚拟机帮助我们隔离了服务。虽然skynet的基础框架设计时并没有限制服务的实现
        形式，理论上可以用其它语言实现skynet服务。

        简单说，可以把skynet理解为一个简单的操作系统，它可以调度数千个lua虚拟机，让它们并行工作。每个虚拟机都可以接收
        其它虚拟机发送过来的消息，以及对其它虚拟机发送消息。每个虚拟机，都可以看成skynet系统下的独立进程，你可以在
        skynet工作时启动新的进程、销毁不再使用的进程、还可以通过调式控制台监管它们。skynet同时掌控了外部的网络数据输
        入，和定时器的管理；它会把这些转换为一致的（类似进程间的消息）消息输入给这些进程。

        例如：
        
        在网络游戏中，你可以为每个在线用户创建一个lua虚拟机（skynet称之为lua服务），姑且把它称为agent。用户在不和其它
        用户交互而仅仅自娱自乐，agent完全可以满足要求。agent在用户上线时，从数据库加载关联于它的所有数据到lua VM中，
        对用户的网络请求作出反应。当然也可以让以个lua服务管理多个在线用户，每个用户是lua虚拟机内的一个对象。

        你还可以用独立的服务处理网络游戏中的副本（或是战场），处理玩家与玩家间，玩家协同对战AI的战斗。agent会和副本服务
        通过消息进行交互，而不必用客户端直接与副本通讯。

        这些都是具体的游戏服务器架构设计，skynet并不要求你应该这么做，甚至不会建议你这么做。一切等你设计时做出决断。

    网络：

        作为网络服务器框架，必然有封装好的网络层，对于skynet更是必不可少。由于skynet模拟了一个简单的操作系统，它最重要
        的工作就是调度上千个服务，如何让服务挂起时，尽量减少对系统的影响是首要解决的问题。我们不建议再使用任何直接与系统
        网络api打交道的模块，因为一旦这个模块被网络IO阻塞，影响的就不只是该服务本身，而是skynet的工作线程了。skynet会被
        配置成固定数量的工作线程，工作线程数通常与系统物理核心相关，而skynet所管理的服务数量则是动态的、远超工作线程数量。
        skynet内置的网络层可以和它的服务调度器协同工作，使用skynet的网络API可以在网络IO阻塞时，完全释放CPU处理能力。

        skynet有监听TCP连接，对外建立TCP连接，收发UDP数据包的能力。你只需要一行代码就可以监听一个端口，接收外部TCP连接。
        当有新的连接建立时，通过一个回调函数可以获得这个新连接的句柄。与你写过的网络应用程序不太一样的是，你还可以把这个
        句柄转交给skynet中的其它服务去处理，以获得并行能力。这有点像传统posix系统中，接收一个新连接后，fork一个子进程继承
        这个句柄来处理的模式。但不一样的是，skynet服务没有父子关系。

        我们通常建议使用使用一个网络服务，专门监听端口，接受新连接。在用户身份确认后，再把真正的业务数据转交给特定的服务来
        处理。同时，网关还会根据约定好的协议，把TCP连接上的数据流切成一个一个的包，而不需要业务处理服务来分割TCP服务流。
        业务处理不必面对socket句柄，而由skynet内部消息驱动即可。这样的网关服务，skynet在发布版里就提供了一个，但它只是
        一个可选模块，你大可以不用它，或自己编写一个类似的服务以更符合你的项目需求。

    客户端：

        客户端demo是基于长连接的，基础协议用2字节大端字来表示每个数据包的长度，skynet网关服务根据这个包长切割成业务逻辑
        数据包，分发给内部服务处理。如果你想使用skynet内置的网关模块，只需要遵循这个基础的分包约定即可。

    服务service：

        skynet服务使用lua5.3编写，只要把符合规定的lua放在skynet可以找到的路径下就可以由其它服务启动。每个服务拥有一个
        唯一的32bit id，skynet把这个id称为服务地址，由skynet框架分配。即使服务退出，该地址也会尽可能长时间的保留，以
        避免当消息发向一个正在退出的服务后，新服务启动顶替该地址，而导致消息发向错误的实体。

        每个服务分三个运行阶段：
            
            首先加载阶段，这个阶段不可以调用任何有可能阻塞住该服务的skynet api。因为，在这个阶段中，和服务配套的skynet
            设置并没有初始化完毕。

            然后是初始化阶段，由skynet.start这个api注册的初始化函数执行。这个初始化函数理论可以调用任何skynet api了，
            但启动该服务的newservice这个api会一直等待初始化函数结束才会返回。

            最后是服务工作阶段，当你在初始化阶段注册了消息处理函数，只要有消息输入，就会触发注册的消息处理函数。这些消息
            都是skynet内部消息，外部网络数据，定时器也会通过内部消息的形式表达出来。

        从skynet底层框架来看，每个服务就是一个消息处理器。但在应用层并非如此。它是利用lua的coroutine工作的。当你的服务
        向另一个服务发送一个请求（即一个带session的消息）后，可以认为当前的消息已经处理完毕，服务会被skynet挂起。待对应
        服务收到请求并做出回应（发送一个回应消息的消息）后，服务会找到挂起coroutine，把回应信息传入，延续之前未完的业务
        流程。从使用者角度看，更像是一个独立线程在处理这个业务流程，每个业务流程有自己独立的上下文，而不像nodejs等其它
        框架中使用的callback模式。

        和erlang不同，一个skynet服务在某个业务流程被挂起后，即使回应消息尚未收到，还是可以处理其它的消息的。所以同一个
        skynet服务可以同时拥有多条业务执行线。所以，尽可以让同一个skynet服务处理很多消息，它们看起来并行，和真正分拆到
        不同的服务中处理的区别是，这些处理流程永远不会真正的并行，它们只是在轮流工作。一段业务会一直运行到下一个IO阻塞点，
        然后切换到下一段逻辑。你可以利用这一点，让多条业务在处理时共享同一组数据，这些数据在同一个lua虚拟机下时，读写起来
        都要比消息交换廉价的多。

        互有利弊的时，一旦业务被挂起，等回应回来时，内部状态可能被同期其它业务处理逻辑改变，请务必小心。在skynet api文档
        中，已经注明哪些api可能导致阻塞，两次阻塞api调用之间，运行过程是原子的，利用这个特性，会比传统多线程程序更容易
        编写。

        在同一服务还可以有用户线程，这些线程可以用skynet.fork传入一个函数启动，也可以利用定时器的回调函数启动。上面提到的
        消息处理处理函数其实也是一条独立的用户线程（可以理解为：相应任何一个请求，都启动了一条新的独立用户线程）。这些并不
        像真正操作系统的线程那样，可以利用多个核心并行运行。同一服务内的不同用户线程永远都是轮流获得执行权的，每个线程都会
        需要一个阻塞操作而挂起让出控制权，也会在其它线程让出控制权后在延续运行。

        如果一条用户线程永远不调用阻塞api让出控制权，那么它将永远占据系统工作线程。skynet并不是一个抢占式调度器，没有时间
        片的设计，不会因为一个工作线程时间过长而强制挂起它。所以开发者需要自己小心，不要陷入死循环。不过skyent也做了一些
        监控工作，会在某个线程占据了太长时间后，以log的形式报告。提醒开发者修正导致死循环的bug。对于lua代码中的死循环bug
        （而不是lua调用C模块导致的死循环）还可以由框架强制中断，

    消息 Message：
        每条skynet消息由6个部分构成：消息类型、session、发起服务地址、接收服务地址、消息C指针、消息长度。

        每个skynet服务可以处理多类消息。在skynet中，是用type这个词来区分消息的。每个服务都支持255个消息类型。消息分发函数
        可以根据不同的类型来为不同的消息定制不同的消息处理流程。

        skynet预定义了一组消息类型，需要开发者关心的有：回应消息、网络消息、调试消息、文本消息、lua消息、错误。

        回应消息通常不需要特别处理，它由skynet基础库管理，用来调度服务内的coroutine。当你对外发起一个请求后，对应会回应一
        个消息，这个消息就是回应消息。发送请求方收到回应消息，会根据消息的session来找到之前对应的请求所在的coroutine，并
        延续它。

        网络消息也不必直接处理它，skynet提供了socket封装库，封装管理这类消息，改由一组更友好的socket api方便使用。

        调试消息已经被默认的skynet基础库处理了。它使得所有skynet服务都提供有一些共同的能力。比如反馈自身虚拟机所占用的内存
        情况、当前被挂起的任务数量、动态注入一段lua代码帮助调试、等等。调试控制台只能通过向对应的服务发送调试消息。

        
*/
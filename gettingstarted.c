
//Getting Started
/*
    skynet入门Quickstart：

        skynet是为网络游戏服务器设计的轻量级框架，但它本身并没有为网络游戏特别设计的部分，尽可以用在其它领域。

        skynet并非开箱即用，不会引导你把服务器搭建起来，而是一套工具，只有知道你想做什么，它才会更有效率的帮助你。

    框架Framework：

        作为服务器，通常需要同时处理多分类似的业务。例如在网络游戏中，你需要同时想数千个用户提供服务；同时运作上百
        个副本，计算副本中的战斗、让NPC通过AI工作起来，等等。在单核年代，我们通常在CPU上轮流处理这些业务，给用户造
        成并行的假象。而现代计算机，则可以配置多达数十个核心，如何充分利用它们并行运作数千个相互独立的业务，是设计
        skynet的初衷。

        简单的web服务倾向于把和用户相关的状态信息存储在数据库，通过用户进行对数据库进行操作和更新。而网络游戏通常有
        更强的上下文，以及多个用户间更复杂的交互。如果采用相同的模块，数据库和业务处理间很容易出现瓶颈，这个瓶颈甚至
        不能通常增加一个cache层来完全解决。

        在skynet中，用服务（service）概念来表达某项具体业务，它包括了处理业务的逻辑以及关联的数据状态。使用skynet
        实现游戏服务器时，不建议把业务状态挂到数据库中，而是存放在服务的内存数据结构里。服务、连同服务处理业务的逻辑
        代码和业务关联的状态数据，都是常驻内存的。如果数据库时你架构的一部分，那么大多数情况下，它扮演的是一个数据
        备份的角色。你可以在状态改变时，把数据推到数据库保存，也可以定期写到数据库备份。业务处理时直接使用内存的数据
        结构。

        由于skynet服务并非独立进程，所以服务间的通讯也可以被实现的高效得多。另一方面，由于这些服务同时存在于同一个
        skynet进程下，我们认为它们同生共死。在编写服务间协作的代码时，不用刻意考虑对方是否还活着、通讯是否可靠的问题。
        大多数skynet服务使用lua编写，lua的虚拟机帮助我们隔离了服务。虽然skynet的基础框架设计时并没有限制服务的实现
        形式，理论上可以用其它语言实现skynet服务。

        简单说，可以把skynet理解为一个简单的操作系统，它可以调度数千个lua虚拟机，让它们并行工作。每个虚拟机都可以接收
        其它虚拟机发送过来的消息，以及对其它虚拟机发送消息。每个虚拟机，都可以看成skynet系统下的独立进程，你可以在
        skynet工作时启动新的进程、销毁不再使用的进程、还可以通过调式控制台监管它们。skynet同时掌控了外部的网络数据输
        入，和定时器的管理；它会把这些转换为一致的（类似进程间的消息）消息输入给这些进程。

        例如：
        
        在网络游戏中，你可以为每个在线用户创建一个lua虚拟机（skynet称之为lua服务），姑且把它称为agent。用户在不和其它
        用户交互而仅仅自娱自乐，agent完全可以满足要求。agent在用户上线时，从数据库加载关联于它的所有数据到lua VM中，
        对用户的网络请求作出反应。当然也可以让以个lua服务管理多个在线用户，每个用户是lua虚拟机内的一个对象。

        你还可以用独立的服务处理网络游戏中的副本（或是战场），处理玩家与玩家间，玩家协同对战AI的战斗。agent会和副本服务
        通过消息进行交互，而不必用客户端直接与副本通讯。

        这些都是具体的游戏服务器架构设计，skynet并不要求你应该这么做，甚至不会建议你这么做。一切等你设计时做出决断。

    网络：

        作为网络服务器框架，必然有封装好的网络层，对于skynet更是必不可少。由于skynet模拟了一个简单的操作系统，它最重要
        的工作就是调度上千个服务，如何让服务挂起时，尽量减少对系统的影响是首要解决的问题。我们不建议再使用任何直接与系统
        网络api打交道的模块，因为一旦这个模块被网络IO阻塞，影响的就不只是该服务本身，而是skynet的工作线程了。skynet会被
        配置成固定数量的工作线程，工作线程数通常与系统物理核心相关，而skynet所管理的服务数量则是动态的、远超工作线程数量。
        skynet内置的网络层可以和它的服务调度器协同工作，使用skynet的网络API可以在网络IO阻塞时，完全释放CPU处理能力。

        skynet有监听TCP连接，对外建立TCP连接，收发UDP数据包的能力。你只需要一行代码就可以监听一个端口，接收外部TCP连接。
        当有新的连接建立时，通过一个回调函数可以获得这个新连接的句柄。与你写过的网络应用程序不太一样的是，你还可以把这个
        句柄转交给skynet中的其它服务去处理，以获得并行能力。这有点像传统posix系统中，接收一个新连接后，fork一个子进程继承
        这个句柄来处理的模式。但不一样的是，skynet服务没有父子关系。

        我们通常建议使用使用一个网络服务，专门监听端口，接受新连接。在用户身份确认后，再把真正的业务数据转交给特定的服务来
        处理。同时，网关还会根据约定好的协议，把TCP连接上的数据流切成一个一个的包，而不需要业务处理服务来分割TCP服务流。
        业务处理不必面对socket句柄，而由skynet内部消息驱动即可。这样的网关服务，skynet在发布版里就提供了一个，但它只是
        一个可选模块，你大可以不用它，或自己编写一个类似的服务以更符合你的项目需求。

    客户端：

        客户端demo是基于长连接的，基础协议用2字节大端字来表示每个数据包的长度，skynet网关服务根据这个包长切割成业务逻辑
        数据包，分发给内部服务处理。如果你想使用skynet内置的网关模块，只需要遵循这个基础的分包约定即可。

    服务service：

        skynet服务使用lua5.3编写，只要把符合规定的lua放在skynet可以找到的路径下就可以由其它服务启动。每个服务拥有一个
        唯一的32bit id，skynet把这个id称为服务地址，由skynet框架分配。即使服务退出，该地址也会尽可能长时间的保留，以
        避免当消息发向一个正在退出的服务后，新服务启动顶替该地址，而导致消息发向错误的实体。
*/